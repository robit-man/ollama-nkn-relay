<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ollama Relay Playground</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: rgba(255, 255, 255, 0.07);
      --panel-2: rgba(255, 255, 255, 0.05);
      --accent: #66e0ff;
      --accent-2: #a8ff60;
      --text: #e8f1f8;
      --muted: #a9b6c3;
      --danger: #ff6b6b;
      --ok: #7dffb0;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius: 16px;
      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 1px rgba(255,255,255,.12);
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body {
      margin: 0; color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial;
      line-height: 1.3; background: transparent; position: relative;
    }
    body::after{
      content:''; z-index:-1; top:0; position:fixed; width:100vw; height:100vh;
      background: radial-gradient(1200px 800px at 10% -10%, #163147, transparent 60%),
                  radial-gradient(900px 600px at 100% 0%, #1b2d18, transparent 55%), var(--bg);
    }
    header{ padding:24px 20px; display:flex; gap:18px; align-items:center; justify-content:space-between }
    .brand{ display:flex; gap:14px; align-items:center; letter-spacing:.4px }
    .logo{ width:40px; height:40px; border-radius:12px; background: conic-gradient(from 220deg, var(--accent), #9f78ff, var(--accent-2)); box-shadow: var(--shadow) }
    .brand h1{ font-size:18px; margin:0; font-weight:700 }
    .hint{ color:var(--muted); font-size:12px }
    .grid{ display:grid; gap:16px; padding:0 20px 24px; grid-template-columns: repeat(12, 1fr) }
    .card{
      grid-column: span 12; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius); box-shadow: var(--shadow); backdrop-filter: blur(8px); padding:16px
    }
    @media (min-width:1080px){
      .span-6{ grid-column: span 6 }
      .span-4{ grid-column: span 4 }
      .span-8{ grid-column: span 8 }
      .span-3{ grid-column: span 3 }
    }
    .card h2{ margin:0 0 8px; font-size:16px }
    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center }
    .row>*{ margin:2px 0 }
    label{ font-size:12px; color:var(--muted); margin-right:6px }
    input[type="text"], input[type="url"], input[type="number"], textarea, select{
      width:100%; background:var(--panel-2); color:var(--text);
      border:1px solid rgba(255,255,255,.15); padding:10px 12px; border-radius:12px; outline:none; font-size:14px
    }
    #chatMsgList{ height:max-content; max-height:1024px; }
    textarea{ resize:vertical; min-height:84px }
    input[type="file" i]::file-selector-button, button{
      background: linear-gradient(180deg, rgba(102,224,255,.9), rgba(102,224,255,.6));
      color:#001018; border:0; padding:10px 14px; font-weight:700; border-radius:12px; cursor:pointer;
      transition:.15s transform ease, .15s filter ease;
      box-shadow: 0 6px 16px rgba(72,218,255,.25), inset 0 0 1px rgba(255,255,255,.6)
    }
    button.secondary{
      background: linear-gradient(180deg, rgba(168,255,96,.9), rgba(168,255,96,.6));
      color:#021204; box-shadow:0 6px 16px rgba(168,255,96,.20), inset 0 0 1px rgba(255,255,255,.6)
    }
    button.ghost{ background:transparent; color:var(--text); border:1px solid rgba(255,255,255,.2) }
    optgroup{ background:#333333 } option{ background:#222222 }
    .badge{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.05) }
    .dot{ width:10px; height:10px; border-radius:50%; background:#999 } .dot.ok{ background:var(--ok); box-shadow:0 0 12px var(--ok) } .dot.warn{ background:#f9c846; box-shadow:0 0 12px #f9c846 } .dot.err{ background:var(--danger); box-shadow:0 0 12px var(--danger) }
    .code{ background:#04070b; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:12px; font-family:var(--mono); font-size:12px; white-space:pre-wrap; color:#d7f0ff; max-height:300px; overflow:auto }
    .muted{ color:var(--muted); font-size:12px } .small{ font-size:11px; color:var(--muted) }
    .two-col{ display:grid; grid-template-columns:1fr 1fr; gap:8px }
    .chat-wrap{ display:grid; grid-template-rows:auto auto 1fr auto; gap:10px; height:auto }
    .chat-toolbar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
    .chat-stream{ background:#04070b; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px; overflow:auto }
    .bubble{ max-width:78%; padding:10px 12px; border-radius:14px; margin:6px 0; white-space:pre-wrap }
    .bubble.user{ background:rgba(255,255,255,.08); margin-left:auto }
    .bubble.assistant{ background:rgba(102,224,255,.14); border:1px solid rgba(102,224,255,.25) }
    .msg-list{ height:100%; overflow:auto; padding:6px }
    .chat-input{ display:flex; gap:8px }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo"></div>
    <div>
      <h1>Ollama Relay Playground</h1>
      <div class="hint">Generate · Chat · Create · Tags · Show · Copy · Delete · Pull/Push · Embed · PS · Version · Blobs</div>
    </div>
  </div>
  <div id="status" class="badge"><span class="dot warn"></span><span>Checking…</span></div>
</header>

<main class="grid">
  <!-- SETTINGS -->
  <section class="card span-6">
    <h2>Settings</h2>
    <div class="row" style="gap:12px">
      <label>Transport</label>
      <select id="transport">
        <option value="http">HTTP(S) Direct</option>
        <option value="nkn">NKN Relay (DM)</option>
      </select>

      <label>Base URL</label>
      <input id="baseUrl" type="url" placeholder="http://127.0.0.1:11434"/>

      <label>Relay NKN Address</label>
      <input id="relayAddr" type="text" placeholder="(full NKN address incl. identifier)"/>

      <label>Auth (optional)</label>
      <input id="apiKey" type="text" placeholder="X-API-Key or Bearer token"/>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="muted">NKN: <span id="nknInfo">disconnected</span></span>
      <div class="row" style="margin-left:auto;">
        <button id="nknConnectBtn">Connect NKN</button>
        <button class="ghost" id="nknDisconnectBtn">Disconnect</button>
        <button class="ghost" id="saveBtn">Save</button>
      </div>
    </div>
    <div class="small" style="margin-top:8px;">Tip: Use HTTP mode for large file uploads to
      <code>/api/blobs/:digest</code>.
    </div>
  </section>

  <!-- INSPECT -->
  <section class="card span-6">
    <h2>Inspect</h2>
    <div class="row" style="gap:8px">
      <button id="listModels">GET /api/tags</button>
      <button id="listPS">GET /api/ps</button>
      <button id="getVersion">GET /api/version</button>
    </div>
    <div id="inspectBox" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- GENERATE -->
  <section class="card span-6">
    <h2>Generate (POST /api/generate)</h2>
    <div class="row" style="gap:8px">
      <label>Model</label><input type="text" id="genModel" placeholder="e.g. llama3.1:8b"/>
      <label>Stream</label>
      <select id="genStream">
        <option value="true" selected>true</option>
        <option value="false">false</option>
      </select>
    </div>
    <textarea id="genPrompt" placeholder="Write a haiku about databases."></textarea>
    <div class="two-col">
      <textarea id="genFormat" placeholder='Optional "format": "json" or JSON schema'></textarea>
      <textarea id="genOptions" placeholder='Optional "options": {...} (JSON)'></textarea>
    </div>
    <div class="row" style="gap:8px;margin-top:8px;">
      <button id="genGo">Send</button>
      <span class="muted">Streams NDJSON unless <code>stream:false</code>.</span>
    </div>
    <div id="genOut" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- CHAT -->
  <section class="card span-6">
    <h2>Chat (POST /api/chat)</h2>
    <div class="chat-wrap">
      <div class="chat-toolbar">
        <label>Model</label>
        <select id="chatModelSelect" style="min-width:260px"></select>

        <label>Session</label>
        <select id="chatSessionSelect" style="min-width:200px"></select>
        <button class="secondary" id="chatNewSession">New</button>
        <button class="ghost" id="chatRenameSession">Rename</button>
        <button class="ghost" id="chatDeleteSession">Delete</button>

        <label>Stream</label>
        <select id="chatStream">
          <option value="true" selected>true</option>
          <option value="false">false</option>
        </select>

        <input type="file" id="chatUpload" accept="application/json" style="margin-left:auto"/>
        <button id="chatDownload">Download JSON</button>
      </div>

      <textarea id="chatSystem" placeholder="System message (optional)"></textarea>

      <div id="chatMsgList" class="msg-list"></div>

      <div class="chat-input">
        <textarea id="chatUserInput" placeholder="Type your message…"></textarea>
        <button id="chatSend">Send</button>
      </div>
    </div>
  </section>

  <!-- MODEL ADMIN -->
  <section class="card span-6">
    <h2>Model Admin</h2>
    <div class="row" style="gap:8px">
      <label>Create model</label><input type="text" id="createModelName" placeholder="new-name[:tag]"/>
      <button class="secondary" id="createFromModel">POST /api/create (from model)</button>
    </div>
    <div class="two-col">
      <textarea id="createSystem" placeholder='system (string)'></textarea>
      <textarea id="createTemplate" placeholder='template (string)'></textarea>
    </div>
    <div class="two-col">
      <textarea id="createParams" placeholder='parameters (JSON)'></textarea>
      <textarea id="createMessages" placeholder='messages (JSON)'></textarea>
    </div>
    <hr style="border:none;border-top:1px solid rgba(255,255,255,.15);margin:12px 0"/>
    <div class="row" style="gap:8px">
      <label>Show</label><input type="text" id="showModel" placeholder="model[:tag]"/>
      <button id="showBtn">POST /api/show</button>
      <label>Verbose</label>
      <select id="showVerbose">
        <option value="false">false</option>
        <option value="true">true</option>
      </select>
    </div>
    <div class="row" style="gap:8px">
      <label>Copy</label><input type="text" id="copySrc" placeholder="source model"/>
      <input type="text" id="copyDst" placeholder="destination"/>
      <button id="copyBtn">POST /api/copy</button>
    </div>
    <div class="row" style="gap:8px">
      <label>Delete</label><input type="text" id="deleteModel" placeholder="model to delete"/>
      <button id="deleteBtn">DELETE /api/delete</button>
    </div>
    <div id="adminOut" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- PULL / PUSH -->
  <section class="card span-6">
    <h2>Pull / Push</h2>
    <div class="row" style="gap:8px">
      <label>Pull</label><input type="text" id="pullModelName" placeholder="model[:tag]"/>
      <button class="secondary" id="pullModel">POST /api/pull</button>
    </div>
    <div class="row" style="gap:8px">
      <label>Push</label><input type="text" id="pushModelName" placeholder="namespace/model:tag"/>
      <button class="secondary" id="pushModel">POST /api/push</button>
    </div>
    <div id="pullPushOut" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- EMBEDDINGS -->
  <section class="card span-6">
    <h2>Embeddings</h2>
    <div class="row" style="gap:8px">
      <label>Model</label><input type="text" id="embModel" placeholder="e.g. all-minilm"/>
      <label>Endpoint</label>
      <select id="embEndpoint">
        <option value="embed" selected>/api/embed</option>
        <option value="embeddings">/api/embeddings (legacy)</option>
      </select>
    </div>
    <textarea id="embInput"
              placeholder='For /api/embed: "input" can be string or ["...","..."]. For legacy /api/embeddings: uses "prompt".'></textarea>
    <div class="two-col">
      <textarea id="embOptions" placeholder='Optional "options": {...} (JSON)'></textarea>
      <textarea id="embKeepAlive" placeholder='Optional "keep_alive": "5m" (string)'></textarea>
    </div>
    <div class="row" style="gap:8px;margin-top:8px;">
      <button id="embGo">Send</button>
    </div>
    <div id="embOut" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- BLOBS -->
  <section class="card span-6">
    <h2>Blobs (/api/blobs/:digest)</h2>
    <div class="row" style="gap:8px">
      <input type="text" id="blobDigest" placeholder="sha256:..."/>
      <button id="blobHead">HEAD (check exists)</button>
    </div>
    <div class="row" style="gap:8px">
      <input type="file" id="blobFile"/>
      <button id="blobPush">POST (upload)</button>
      <span class="muted">HTTP mode recommended for big files; NKN path allows small files only.</span>
    </div>
    <div id="blobOut" class="code" style="margin-top:8px; display:none;"></div>
  </section>

  <!-- STATUS / LOGS -->
  <section class="card span-6">
    <h2>Status / Logs</h2>
    <div id="statusBox" class="code" style="display:block;min-height:80px;">(logs)</div>
  </section>
</main>

<script>
/* =====================================================================
   OLLAMA FRONTEND (RESILIENT)
   - Auto-heals NKN client (restarts with backoff on close/error)
   - Relay heartbeat (NKN ping + HTTP ping) with UI status
   - Background models poller with adaptive (backoff) retry
   - Async model discovery runs forever; no overlap; safe on tab hide/show
   ===================================================================== */

/* ===================== STATE ===================== */
const STREAM_GRACE_MS = 240;      // accept late line batches after "end"
const MODELS_BASE_POLL_MS = 15000;// background poll on success
const MODELS_MAX_BACKOFF_MS = 60000;
const NKN_PING_EVERY_MS = 12000;  // ask relay for info/pong
const NKN_STALE_AFTER_MS = 30000; // if no pong/info seen in this window -> reconnect
const HTTP_PING_EVERY_MS = 20000; // ping /api/version for base health
const VISIBILITY_DEBOUNCE_MS = 1000;

const S = {
  // persisted
  transport: localStorage.getItem('ollama.transport') || 'http',
  base:      localStorage.getItem('ollama.base') || 'http://127.0.0.1:11434',
  relayAddr: localStorage.getItem('ollama.relayAddr') || '',
  apiKey:    localStorage.getItem('ollama.apiKey') || '',

  // models
  models: [],
  _modelsReqInFlight: false,
  _modelsLastReq: 0,
  _modelsRequestsIssued: 0,
  _modelsRetryTimer: null,
  _modelsFailCount: 0, // for backoff
  _modelsPollTimer: null,

  // health (http)
  http: { healthy: null, lastSeen: 0, pingTimer: null },

  // nkn subsystem
  nkn: {
    client: null,
    addr: '',
    ready: false,
    pending: new Map(),     // id -> {resolve,reject,timer}
    streams: new Map(),     // id -> ctx
    nextId: 1,
    readyCbs: [],
    // resilience
    restarting: false,
    backoffMs: 500,         // exp backoff
    maxBackoffMs: 15000,
    restartTimer: null,
    pingTimer: null,
    lastSeen: 0,            // time of last relay.info / relay.pong we saw
  },

  // chat store
  chat: {
    key: 'ollama.chat.v1',
    byModel: {},
    currentModel: null,
    sid: null
  }
};

/* ===================== HELPERS ===================== */
function qs(id){ return document.getElementById(id) }
function j(x){ try{ return JSON.stringify(x, null, 2) } catch{ return String(x) } }
function parseMaybeJSON(txt){ const t=(txt||'').trim(); if(!t) return undefined; try{ return JSON.parse(t); } catch{ return t; } }
function downloadJSON(filename, obj){ const blob = new Blob([JSON.stringify(obj, null, 2)],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url),500); }
function b64ToBytes(b64){ const bin=atob(b64); const len=bin.length; const out=new Uint8Array(len); for(let i=0;i<len;i++) out[i]=bin.charCodeAt(i); return out; }
function bytesToB64(arr){ let bin=''; const bytes=new Uint8Array(arr); for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); }
function now(){ return Date.now() }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)) }
function nextBackoff(cur, cap){ return clamp(cur*2, 500, cap) }
function logStatus(txt, ok=true){ const st=qs('status'); if(!st) return; st.innerHTML = `<span class="dot ${ok?'ok':'err'}"></span><span>${txt}</span>`; }
function toast(txt, ok=true){
  logStatus(txt, ok);
  setTimeout(()=>{ logStatus('Ready', true) }, 1400);
}
function authHeaders(h={}){
  const headers=Object.assign({}, h);
  if(!headers['Content-Type']) headers['Content-Type']='application/json';
  if(S.apiKey){
    if(S.apiKey.startsWith('Bearer ')) headers['Authorization']=S.apiKey;
    else headers['X-API-Key']=S.apiKey;
  }
  return headers;
}

/* ===================== MODELS REFRESH (RETRY + POLLER) ===================== */
function _scheduleModelsRetry(ms){
  clearTimeout(S._modelsRetryTimer);
  S._modelsRetryTimer = setTimeout(()=>{ refreshModels() }, ms);
}
function _startModelsPoller(){
  clearTimeout(S._modelsPollTimer);
  const baseDelay = MODELS_BASE_POLL_MS;
  S._modelsPollTimer = setInterval(()=>{
    // Don't pile up; only poll if idle and tab visible
    if (S._modelsReqInFlight) return;
    if (document.hidden) return;
    refreshModels(/*silent=*/true);
  }, baseDelay);
}
async function refreshModels(silent=false){
  if (S._modelsReqInFlight) return;
  S._modelsReqInFlight = true;
  S._modelsLastReq = now();
  S._modelsRequestsIssued++;

  try{
    const data = await getJSON('/api/tags');
    const list = Array.isArray(data?.models) ? data.models : [];

    const groups = new Map();
    for (const m of list){
      const nm = typeof m?.name === 'string' ? m.name : (typeof m?.model === 'string' ? m.model : null);
      if (!nm) continue;
      const { base, tag, full } = splitModelName(nm);
      if (!groups.has(base)) groups.set(base, { tags: new Set(), byTag: new Map() });
      const g = groups.get(base);
      g.tags.add(tag);
      g.byTag.set(tag, { full, tag, base, details: m?.details || {}, raw: m });
    }

    const sel = qs('chatModelSelect');
    if (sel){
      sel.innerHTML = '';
      const bases = Array.from(groups.keys()).sort((a,b)=>a.localeCompare(b, undefined, { numeric:true }));
      for (const base of bases){
        const g = groups.get(base);
        const tags = Array.from(g.tags).sort(naturalTagSort);
        const og = document.createElement('optgroup');
        og.label = base;
        for (const tag of tags){
          const mo = g.byTag.get(tag);
          const opt = document.createElement('option');
          opt.value = mo.full;
          const sz = mo.details?.parameter_size ? ` · ${mo.details.parameter_size}` : '';
          const ql = mo.details?.quantization_level ? ` · ${mo.details.quantization_level}` : '';
          opt.textContent = `${tag}${sz}${ql}`;
          og.appendChild(opt);
        }
        sel.appendChild(og);
      }
      S.models = Array.from(groups.keys()).flatMap(base=>{
        const g = groups.get(base);
        return Array.from(g.tags).map(tag=>g.byTag.get(tag).full);
      });

      // choose current model
      const want = S.chat.currentModel && S.models.includes(S.chat.currentModel)
        ? S.chat.currentModel
        : (S.models[0] || null);
      S.chat.currentModel = want;
      if (want) sel.value = want;
      renderSessionListForModel();
    }

    S._modelsFailCount = 0;
    if (!silent) toast('Models loaded');
    // keep polling in background; no special reschedule needed (interval handles it)
  } catch(e){
    S._modelsFailCount++;
    const backoff = clamp(500 * (2 ** (S._modelsFailCount-1)), 1000, MODELS_MAX_BACKOFF_MS);
    if (!silent) toast('Load models failed; retrying…', false);
    _scheduleModelsRetry(backoff);
  } finally {
    S._modelsReqInFlight = false;
  }
}
function splitModelName(name){
  const i = name.lastIndexOf(':');
  if (i === -1) return { base: name, tag:'latest', full: name };
  return { base: name.slice(0,i), tag: name.slice(i+1)||'latest', full: name };
}
function naturalTagSort(a,b){
  const ax=a.toLowerCase(), bx=b.toLowerCase();
  if (ax==='latest' && bx!=='latest') return 1;
  if (bx==='latest' && ax!=='latest') return -1;
  const rex=/^(\d+(?:\.\d+)?)\s*([kmgbt]*)$/;
  const pa=ax.match(rex), pb=bx.match(rex);
  if (pa && pb){
    const na=parseFloat(pa[1]), nb=parseFloat(pb[1]);
    if (!Number.isNaN(na) && !Number.isNaN(nb)){
      if (na!==nb) return na-nb;
      return ax.localeCompare(bx);
    }
  }
  const pba=ax.match(/^(\d+(?:\.\d+)?)b$/), pbb=bx.match(/^(\d+(?:\.\d+)?)b$/);
  if (pba && pbb){
    const na=parseFloat(pba[1]), nb=parseFloat(pbb[1]);
    if (na!==nb) return na-nb;
  }
  return ax.localeCompare(bx);
}

/* ===================== TRANSPORT HEALTH ===================== */
function reflectTransportUI(){
  const el = qs('nknInfo');
  if (!el) return;
  if (S.transport !== 'nkn'){ el.textContent = 'disabled'; return; }
  if (S.nkn.ready){
    const since = Math.max(0, now()-S.nkn.lastSeen);
    el.textContent = `connected • ${S.nkn.addr.slice(0,10)}…${since>15000?' (stale)': ''}`;
  } else {
    el.textContent = S.nkn.restarting ? `retrying in ${(S.nkn.backoffMs/1000).toFixed(1)}s…` : 'connecting…';
  }
}

/* ===================== NKN LAYER (RESILIENT) ===================== */
function _bindNknHandlers(client){
  client.on('connect', ()=>{
    S.nkn.addr = client.addr || '';
    S.nkn.ready = true;
    S.nkn.restarting = false;
    S.nkn.backoffMs = 500;
    S.nkn.lastSeen = now();
    (S.nkn.readyCbs||[]).forEach(fn=>{ try{ fn() }catch{} });
    S.nkn.readyCbs.length = 0;
    reflectTransportUI(); toast('NKN connected');

    // kick model poll immediately on first connect
    refreshModels(true);
  });

  client.on('message', (a,b)=>{
    let src, payload; if (a && typeof a==='object' && a.payload!==undefined){ src=a.src; payload=a.payload; } else { src=a; payload=b; }
    try{
      const txt = (payload && payload.toString) ? payload.toString() : (''+payload);
      const msg = JSON.parse(txt);
      const ev = msg.event || ''; const id = msg.id;

      // relay keepalive responses
      if (ev === 'relay.info' || ev === 'relay.pong'){
        S.nkn.lastSeen = now();
        reflectTransportUI();
        return;
      }

      // Streamed batches
      if (ev === 'relay.response.lines' && id){
        const ctx = S.nkn.streams.get(id); if (!ctx) return;
        const arr = Array.isArray(msg.lines) ? msg.lines : [];
        for (const item of arr){
          const seq = item.seq|0;
          ctx.buff.set(seq, item);
          ctx.maxSeq = Math.max(ctx.maxSeq, seq);
        }
        _drainOrderedLines(ctx);
        if (ctx.ended) _scheduleFinalize(ctx, 'late-lines');
        return;
      }

      if (ev === 'relay.response.begin' && id){
        const ctx = S.nkn.streams.get(id); if (!ctx) return;
        ctx.onBegin && ctx.onBegin(msg);
        return;
      }

      if (ev === 'relay.response.keepalive' && id){
        const ctx = S.nkn.streams.get(id); if (ctx) ctx.lastHeartbeat = now();
        return;
      }

      if (ev === 'relay.response.end' && id){
        const ctx = S.nkn.streams.get(id); if (!ctx) return;
        ctx.ended = true;
        _scheduleFinalize(ctx, 'end');
        return;
      }

      // Non-stream single-shot
      if (ev === 'relay.response' && id){
        const p = S.nkn.pending.get(id); if (p){ clearTimeout(p.timer); S.nkn.pending.delete(id); p.resolve(msg); }
      }
    }catch{ /* ignore */ }
  });

  const onCloseOrError = ()=>{
    S.nkn.ready = false;
    reflectTransportUI();
    // ensure we try reconnect with backoff
    nknScheduleRestart();
  };
  client.on('close', onCloseOrError);
  client.on('error', onCloseOrError);
}

function nknEnsureClient(){
  if (S.nkn.client) return;
  if (!window.nkn || !(window.nkn.MultiClient || window.nkn.Client)){
    toast('nkn-sdk not loaded', false);
    return;
  }
  const client = new window.nkn.MultiClient({ identifier: 'webui', numSubClients: 4 });
  S.nkn.client = client;
  _bindNknHandlers(client);

  // start pingers
  startNknPingLoop();
}

function nknScheduleRestart(){
  // if client exists, let it attempt auto-reconnect; but also supervise
  if (S.nkn.restartTimer) return;
  S.nkn.restarting = true;
  const wait = S.nkn.backoffMs = nextBackoff(S.nkn.backoffMs, S.nkn.maxBackoffMs);
  reflectTransportUI();
  S.nkn.restartTimer = setTimeout(()=>{
    S.nkn.restartTimer = null;
    // Hard re-init if not ready yet (fresh client)
    try{ if (S.nkn.client && S.nkn.client.close) S.nkn.client.close() }catch{}
    S.nkn.client = null;
    nknEnsureClient();
  }, wait);
}

function nknWaitReady(timeoutMs=20000){
  return new Promise((resolve, reject)=>{
    if (S.nkn.ready) return resolve();
    nknEnsureClient();
    const t = setTimeout(()=>{ cleanup(); reject(new Error('NKN connect timeout')); }, timeoutMs);
    function onReady(){ cleanup(); resolve(); }
    function cleanup(){ clearTimeout(t); S.nkn.readyCbs = (S.nkn.readyCbs||[]).filter(fn=>fn!==onReady); }
    (S.nkn.readyCbs = S.nkn.readyCbs||[]).push(onReady);
  });
}

function startNknPingLoop(){
  clearInterval(S.nkn.pingTimer);
  S.nkn.pingTimer = setInterval(async ()=>{
    if (S.transport !== 'nkn') return;
    if (!S.relayAddr) return;
    // If we've gone stale, force restart path
    if (S.nkn.ready && (now() - S.nkn.lastSeen) > NKN_STALE_AFTER_MS){
      // send a ping, and also schedule restart so we heal even if ping can't be sent
      try{ await nknSendDM({event:'relay.info'}); }catch{}
      nknScheduleRestart();
      return;
    }
    // routine ping when connected
    if (S.nkn.ready){
      try{ await nknSendDM({event:'relay.info'}); }catch{/* ignore */ }
    }
  }, NKN_PING_EVERY_MS);
}

async function nknSendDM(body){
  if (!S.relayAddr) throw new Error('No relay address set');
  await nknWaitReady();
  const client = S.nkn.client;
  return client.send(S.relayAddr, JSON.stringify(body), { noReply: false, maxHoldingSeconds: 60 }).catch(()=>{ /* ignore */});
}

async function nknSendRelayStream(reqSpec, handlers={}, timeoutMs=180000){
  if (!S.relayAddr) throw new Error('No relay address set');
  await nknWaitReady();
  const client = S.nkn.client;
  const id = 'web-' + now() + '-' + (S.nkn.nextId++);
  const ctx = {
    id,
    onBegin: handlers.onBegin || null,
    onLine: handlers.onLine || null,
    onEnd: handlers.onEnd || null,
    onResolve: null,
    onReject: null,
    expected: 1,
    buff: new Map(),
    maxSeq: 0,
    lastHeartbeat: now(),
    ended: false,
    finalizeTimer: null,
    resolved: false
  };
  const p = new Promise((resolve, reject)=>{
    ctx.onResolve = (m)=>{ if (ctx.resolved) return; ctx.resolved = true; try{ ctx.onEnd && ctx.onEnd(m) }catch{} resolve(m); };
    ctx.onReject  = (e)=>{ if (ctx.resolved) return; ctx.resolved = true; reject(e); };
  });
  S.nkn.streams.set(id, ctx);

  const data = { event:'http.request', id, req: Object.assign({ stream:'chunks' }, reqSpec) };
  const timer = setTimeout(()=>{
    if (S.nkn.streams.has(id)){
      try { _drainOrderedLines(ctx, true); } catch {}
      S.nkn.streams.delete(id);
      ctx.onReject && ctx.onReject(new Error('NKN relay timeout'));
    }
  }, timeoutMs);
  p.finally(()=>clearTimeout(timer));

  await client.send(S.relayAddr, JSON.stringify(data), { noReply:true, maxHoldingSeconds:120 });
  return p;
}
async function nknSendRelay(reqSpec, timeoutMs=45000){
  if (!S.relayAddr) throw new Error('No relay address set');
  await nknWaitReady();
  const client = S.nkn.client; const id = 'web-' + now() + '-' + (S.nkn.nextId++);
  const data = { event:'http.request', id, req: reqSpec };
  return new Promise((resolve, reject)=>{
    const timer = setTimeout(()=>{ S.nkn.pending.delete(id); reject(new Error('NKN relay timeout')); }, timeoutMs);
    S.nkn.pending.set(id, { resolve, reject, timer });
    client.send(S.relayAddr, JSON.stringify(data), { noReply:true, maxHoldingSeconds:120 })
      .catch(err=>{ clearTimeout(timer); S.nkn.pending.delete(id); reject(err); });
  });
}
function _drainOrderedLines(ctx, force=false){
  while(true){
    const item = ctx.buff.get(ctx.expected);
    if (!item) break;
    ctx.buff.delete(ctx.expected);
    try { ctx.onLine && ctx.onLine(item.line, item.seq, item.ts); } catch {}
    ctx.expected++;
  }
  if (force && ctx.buff.size){
    const keys = Array.from(ctx.buff.keys()).sort((a,b)=>a-b);
    for (const k of keys){
      const item = ctx.buff.get(k);
      try { ctx.onLine && ctx.onLine(item.line, item.seq, item.ts); } catch {}
      ctx.buff.delete(k);
    }
  }
}
function _scheduleFinalize(ctx, reason){
  clearTimeout(ctx.finalizeTimer);
  ctx.finalizeTimer = setTimeout(()=>{
    try { _drainOrderedLines(ctx, true); } catch {}
    if (S.nkn.streams.has(ctx.id)) S.nkn.streams.delete(ctx.id);
    ctx.onResolve && ctx.onResolve({ ok:true, reason });
  }, STREAM_GRACE_MS);
}

/* ===================== HTTP/Relay CALLS (with base ping) ===================== */
async function httpPingBase(){
  try{
    const res = await fetch(S.base.replace(/\/+$/, '')+'/api/version', { headers: authHeaders() });
    if (res.ok){
      S.http.healthy = true;
      S.http.lastSeen = now();
      return true;
    }
  }catch{}
  S.http.healthy = false;
  return false;
}
function startHttpPingLoop(){
  clearInterval(S.http.pingTimer);
  S.http.pingTimer = setInterval(()=>{ if (S.transport==='http') httpPingBase().catch(()=>{}) }, HTTP_PING_EVERY_MS);
}

async function callJSON(path, bodyObj, extraHeaders, method='POST'){
  if (S.transport === 'nkn'){
    const req = { url: S.base.replace(/\/+$/, '')+path, method, headers: authHeaders(extraHeaders||{}), json: bodyObj ?? {}, timeout_ms: 120000 };
    const resp = await nknSendRelay(req, req.timeout_ms);
    if (!resp || resp.ok===false) throw new Error((resp && resp.error) || ('HTTP '+(resp && resp.status)));
    return resp.json ?? (resp.body_b64 ? JSON.parse(new TextDecoder('utf-8').decode(b64ToBytes(resp.body_b64))) : null);
  }
  const res = await fetch(S.base.replace(/\/+$/, '')+path, { method, headers: authHeaders(extraHeaders), body: bodyObj ? JSON.stringify(bodyObj) : undefined });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}
async function getJSON(path, extraHeaders){
  if (S.transport === 'nkn'){
    const req = { url: S.base.replace(/\/+$/, '')+path, method:'GET', headers: authHeaders(extraHeaders||{}), timeout_ms: 45000 };
    const resp = await nknSendRelay(req, req.timeout_ms);
    if (!resp || resp.ok===false) throw new Error((resp && resp.error) || ('HTTP '+(resp && resp.status)));
    return resp.json ?? (resp.body_b64 ? JSON.parse(new TextDecoder('utf-8').decode(b64ToBytes(resp.body_b64))) : null);
  }
  const res = await fetch(S.base.replace(/\/+$/, '')+path, { headers: authHeaders(extraHeaders) });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}
async function headBlob(digest){
  const url = S.base.replace(/\/+$/, '')+`/api/blobs/${encodeURIComponent(digest)}`;
  if (S.transport === 'nkn'){
    const req = { url, method:'HEAD', headers: authHeaders({'Content-Type':'application/octet-stream'}), timeout_ms: 20000 };
    const resp = await nknSendRelay(req, req.timeout_ms);
    if (!resp) throw new Error('no response');
    return { status: resp.status, headers: resp.headers };
  } else {
    const res = await fetch(url, { method:'HEAD', headers: authHeaders({'Content-Type':'application/octet-stream'}) });
    return { status: res.status, headers: Object.fromEntries(res.headers.entries()) };
  }
}
async function postBlob(digest, file){
  const url = S.base.replace(/\/+$/, '')+`/api/blobs/${encodeURIComponent(digest)}`;
  if (S.transport === 'nkn'){
    if (file.size > 4*1024*1024) throw new Error('File too large for NKN upload; switch to HTTP');
    const buf = await file.arrayBuffer(); const body_b64 = bytesToB64(new Uint8Array(buf));
    const req = { url, method:'POST', headers:{'Content-Type':'application/octet-stream'}, body_b64, timeout_ms: 300000 };
    const resp = await nknSendRelay(req, req.timeout_ms);
    if (!resp || resp.ok===false) throw new Error((resp && resp.error) || ('HTTP '+(resp && resp.status)));
    return { status: resp.status, headers: resp.headers };
  } else {
    const res = await fetch(url, { method:'POST', headers: { 'Content-Type':'application/octet-stream', ...(S.apiKey ? (S.apiKey.startsWith('Bearer ') ? { 'Authorization': S.apiKey } : { 'X-API-Key': S.apiKey }) : {}) }, body: file });
    return { status: res.status, headers: Object.fromEntries(res.headers.entries()) };
  }
}

/* ===================== CHAT PERSISTENCE ===================== */
function loadChatStore(){ try{ const raw=localStorage.getItem(S.chat.key); const obj = raw?JSON.parse(raw):{}; S.chat.byModel = obj.byModel || {}; } catch{ S.chat.byModel = {}; } }
function saveChatStore(){ const payload={ byModel: S.chat.byModel }; localStorage.setItem(S.chat.key, JSON.stringify(payload)); }
function ensureModelBucket(model){ if (!S.chat.byModel[model]) S.chat.byModel[model] = { sessions: {}, lastUsedSid: null }; return S.chat.byModel[model]; }
function newSession(model, name){
  const bucket=ensureModelBucket(model);
  const sid = model + '-' + Date.now().toString(36);
  bucket.sessions[sid] = { name: name || 'Session ' + new Date().toLocaleString(), system:'', messages:[], updatedAt: now() };
  bucket.lastUsedSid = sid; saveChatStore(); return sid;
}
function renameSession(model, sid, name){ const b=ensureModelBucket(model); if (b.sessions[sid]){ b.sessions[sid].name = name || b.sessions[sid].name; b.sessions[sid].updatedAt = now(); saveChatStore(); } }
function deleteSession(model, sid){ const b=ensureModelBucket(model); delete b.sessions[sid]; if (b.lastUsedSid===sid) b.lastUsedSid = Object.keys(b.sessions)[0] || null; saveChatStore(); }
function listSessions(model){ return Object.entries(ensureModelBucket(model).sessions).sort((a,b)=> (b[1].updatedAt||0) - (a[1].updatedAt||0)); }

/* ===================== CHAT UI RENDER ===================== */
function renderSessionListForModel(){
  const model=S.chat.currentModel; if (!model) return;
  const sel = qs('chatSessionSelect'); if (!sel) return;
  sel.innerHTML='';
  const bucket = ensureModelBucket(model);
  if (!bucket.lastUsedSid) bucket.lastUsedSid = newSession(model);
  for (const [sid, sess] of listSessions(model)){
    const o=document.createElement('option'); o.value=sid; o.textContent=sess.name; sel.appendChild(o);
  }
  sel.value = bucket.lastUsedSid;
  S.chat.sid = bucket.lastUsedSid;
  renderChatSession();
}
function renderChatSession(){
  const model=S.chat.currentModel; const sid=S.chat.sid; if (!model || !sid) return;
  const sess=ensureModelBucket(model).sessions[sid]; if (!sess) return;
  const sys = qs('chatSystem'); if (sys) sys.value = sess.system || '';
  const list=qs('chatMsgList'); if (!list) return; list.innerHTML='';
  for (const m of sess.messages){
    const d=document.createElement('div'); d.className='bubble ' + (m.role==='user'?'user':'assistant'); d.textContent = m.content || ''; list.appendChild(d);
  }
  list.scrollTop = list.scrollHeight;
}
function upsertAssistantInFlight(textChunk){
  const list=qs('chatMsgList'); if (!list) return;
  let last=list.lastElementChild;
  if (!last || !last.classList.contains('assistant')){
    last = document.createElement('div'); last.className='bubble assistant'; last.textContent=''; list.appendChild(last);
  }
  last.textContent += textChunk;
  list.scrollTop = list.scrollHeight;
}

/* ===================== CHAT ACTIONS ===================== */
function currentSession(){ const model=S.chat.currentModel; const sid=S.chat.sid; if(!model||!sid) return null; return ensureModelBucket(model).sessions[sid]; }
function setSystemFromUI(){ const sess=currentSession(); if(!sess) return; const el=qs('chatSystem'); sess.system = el? (el.value||'') : ''; sess.updatedAt=now(); saveChatStore(); }
function pushUserMessage(txt){ const sess=currentSession(); if(!sess) return; sess.messages.push({ role:'user', content: txt }); sess.updatedAt=now(); saveChatStore(); }
function pushAssistantMessageFinal(txt){
  const sess=currentSession(); if(!sess) return;
  const last=sess.messages[sess.messages.length-1];
  if (last && last.role==='assistant'){ last.content = (last.content||'') + txt; }
  else sess.messages.push({ role:'assistant', content: txt });
  sess.updatedAt=now(); saveChatStore();
}
function startAssistantInFlight(){
  const sess=currentSession(); if(!sess) return;
  const last=sess.messages[sess.messages.length-1];
  if (last && last.role==='assistant') return;
  sess.messages.push({ role:'assistant', content:'' }); sess.updatedAt=now(); saveChatStore();
}
function appendAssistantInFlight(txt){
  const sess=currentSession(); if(!sess) return;
  const last=sess.messages[sess.messages.length-1]; if (last && last.role==='assistant'){ last.content = (last.content||'') + txt; sess.updatedAt=now(); saveChatStore(); }
}
function assembleAPIMessages(sess){
  const arr=[];
  if (sess.system && sess.system.trim()) arr.push({ role:'system', content: sess.system });
  for (const m of sess.messages) arr.push({ role:m.role, content:m.content });
  return arr;
}

/* ===================== STREAM PARSE ===================== */
const EOT_TOKENS = ["<|eot_id|>", "</s>"];
function stripEOT(s){ let out=s; for (const tok of EOT_TOKENS){ if (!tok) continue; out = out.split(tok).join(''); } return out; }
function processNdjsonLine(line, kind){
  try{
    const obj = JSON.parse(line);
    if (kind === 'chat'){
      if (obj.message && typeof obj.message.content === 'string')
        return { type:'delta', text: stripEOT(obj.message.content), done: !!obj.done };
      if (typeof obj.response === 'string')
        return { type:'delta', text: stripEOT(obj.response), done: !!obj.done };
      return { type:'meta', obj };
    } else {
      if (typeof obj.response === 'string') return { type:'delta', text: stripEOT(obj.response), done: !!obj.done };
      return { type:'meta', obj };
    }
  }catch{ return { type:'text', text: line }; }
}

/* ===================== CHAT SEND ===================== */
async function chatSend(){
  setSystemFromUI();
  const model=S.chat.currentModel;
  const stream = qs('chatStream')?.value === 'true';
  const userEl = qs('chatUserInput'); const userText = userEl ? userEl.value : '';
  if (!userText.trim()){ toast('Type a message', false); return; }
  pushUserMessage(userText); if (userEl) userEl.value=''; renderChatSession();

  const sess=currentSession(); if (!sess) return;
  const payload={ model, messages: assembleAPIMessages(sess), stream };

  if (S.transport==='nkn' && stream){
    startAssistantInFlight();
    const req = { url: S.base.replace(/\/+$/, '')+'/api/chat', method:'POST', headers: authHeaders({ 'X-Relay-Stream':'chunks' }), json: payload, timeout_ms: 180000 };
    const handlers = {
      onBegin: ()=>{},
      onLine: (line, seq, ts)=>{
        const ev=processNdjsonLine(line, 'chat');
        if (ev.type==='delta' && ev.text){ appendAssistantInFlight(ev.text); upsertAssistantInFlight(ev.text); }
      },
      onEnd: ()=>{}
    };
    try{
      await nknSendRelayStream(req, handlers, req.timeout_ms);
      renderChatSession(); toast('Chat complete');
    }catch(e){
      upsertAssistantInFlight(`\n[error: ${e.message}]`); toast('Chat failed', false);
    }
    return;
  }

  if (S.transport==='http' && stream){
    startAssistantInFlight();
    try{
      const res = await fetch(S.base.replace(/\/+$/, '')+'/api/chat', { method:'POST', headers: authHeaders({'Content-Type':'application/json'}), body: JSON.stringify(payload) });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const reader = res.body.getReader(); const decoder = new TextDecoder('utf-8'); let leftover='';
      while(true){
        const { value, done } = await reader.read(); if (done) break;
        const s = decoder.decode(value, { stream:true }); const combined = leftover + s; const lines = combined.split(/\r?\n/); leftover = lines.pop() || '';
        for (const ln of lines){
          if (!ln.trim()) continue;
          const ev = processNdjsonLine(ln, 'chat');
          if (ev.type==='delta' && ev.text){ appendAssistantInFlight(ev.text); upsertAssistantInFlight(ev.text); }
        }
      }
      if (leftover.trim()){
        const ev = processNdjsonLine(leftover, 'chat');
        if (ev.type==='delta' && ev.text){ appendAssistantInFlight(ev.text); upsertAssistantInFlight(ev.text); }
      }
      renderChatSession(); toast('Chat complete');
    }catch(e){
      upsertAssistantInFlight(`\n[error: ${e.message}]`); toast('Chat failed', false);
    }
    return;
  }

  // Non-stream
  try{
    const data = await callJSON('/api/chat', payload);
    const text = (data?.message?.content) || (data?.response) || '';
    pushAssistantMessageFinal(text); renderChatSession(); toast('Chat complete');
  }catch(e){
    upsertAssistantInFlight(`\n[error: ${e.message}]`); toast('Chat failed', false);
  }
}

/* ===================== GENERATE ===================== */
async function doGenerate(){
  const model = qs('genModel')?.value.trim(); if (!model){ toast('Enter a model', false); return; }
  const prompt = qs('genPrompt')?.value || '';
  const stream = qs('genStream')?.value === 'true';
  const fmt = parseMaybeJSON(qs('genFormat')?.value);
  const opts = parseMaybeJSON(qs('genOptions')?.value);
  const out = qs('genOut'); if (out){ out.style.display='block'; out.textContent=''; }
  const payload = { model, prompt, stream, ...(fmt!==undefined ? { format: fmt } : {}), ...(opts ? { options: opts } : {}) };

  if (S.transport==='nkn' && stream){
    const req = { url: S.base.replace(/\/+$/, '')+'/api/generate', method:'POST', headers: authHeaders({ 'X-Relay-Stream':'chunks' }), json: payload, timeout_ms: 180000 };
    const handlers = {
      onBegin: ()=>{ if (out) out.textContent=''; },
      onLine: (line)=>{ const ev=processNdjsonLine(line, 'generate'); if (ev.type==='delta' && ev.text){ if(out){ out.textContent += ev.text; out.scrollTop = out.scrollHeight; } } },
      onEnd: ()=>{}
    };
    try { await nknSendRelayStream(req, handlers, req.timeout_ms); toast('Generate complete'); }
    catch(e){ if (out) out.textContent += '\nError: ' + e.message; toast('Generate failed', false); }
  } else if (S.transport==='http' && stream){
    try{
      const res = await fetch(S.base.replace(/\/+$/, '')+'/api/generate', { method:'POST', headers: authHeaders({'Content-Type':'application/json'}), body: JSON.stringify(payload) });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const reader=res.body.getReader(); const decoder=new TextDecoder('utf-8'); let leftover='';
      while(true){
        const { value, done } = await reader.read(); if (done) break;
        const s=decoder.decode(value, { stream:true }); const combined=leftover+s; const lines=combined.split(/\r?\n/); leftover = lines.pop() || '';
        for (const ln of lines){ if (!ln.trim()) continue; const ev=processNdjsonLine(ln,'generate'); if (ev.type==='delta' && ev.text){ if(out){ out.textContent += ev.text; out.scrollTop = out.scrollHeight; } } }
      }
      if (leftover){ const ev=processNdjsonLine(leftover,'generate'); if (ev.type==='delta' && ev.text && out) out.textContent += ev.text; }
      toast('Generate complete');
    }catch(e){ if (out) out.textContent += '\nError: ' + e.message; toast('Generate failed', false); }
  } else {
    try { if (out) out.textContent = j(await callJSON('/api/generate', payload)); toast('Generate complete'); }
    catch(e){ if (out) out.textContent = 'Error: ' + e.message; toast('Generate failed', false); }
  }
}

/* ===================== INSPECT ===================== */
async function listModels(){ const box=qs('inspectBox'); if (box){ box.style.display='block'; } try{ if (box) box.textContent = j(await getJSON('/api/tags')); toast('Loaded models'); }catch(e){ if (box) box.textContent='Error: '+e.message; toast('Models error', false); } }
async function listPS(){ const box=qs('inspectBox'); if (box){ box.style.display='block'; } try{ if (box) box.textContent = j(await getJSON('/api/ps')); toast('Loaded running models'); }catch(e){ if (box) box.textContent='Error: '+e.message; toast('PS error', false); } }
async function getVersion(){ const box=qs('inspectBox'); if (box){ box.style.display='block'; } try{ if (box) box.textContent = j(await getJSON('/api/version')); toast('Got version'); }catch(e){ if (box) box.textContent='Error: '+e.message; toast('Version error', false); } }

/* ===================== ADMIN ===================== */
async function createFromModel(){
  const model = qs('createModelName')?.value.trim(); if (!model){ toast('Enter new model name', false); return; }
  const from = prompt('From base model (e.g. llama3.2 or llama3.1:8b-instruct-fp16)?', 'llama3.2') || '';
  const system = qs('createSystem')?.value || undefined;
  const template = qs('createTemplate')?.value || undefined;
  const parameters = parseMaybeJSON(qs('createParams')?.value);
  const messages = parseMaybeJSON(qs('createMessages')?.value);
  const body = { model, ...(from?{from}:{}) , ...(system?{system}:{}) , ...(template?{template}:{}) , ...(parameters?{parameters}:{}) , ...(Array.isArray(messages)?{messages}:{}) , stream:true };
  const box=qs('adminOut'); if (box){ box.style.display='block'; box.textContent='(creating…)\n'; }

  if (S.transport==='nkn'){
    const req = { url: S.base.replace(/\/+$/, '')+'/api/create', method:'POST', headers: authHeaders({ 'X-Relay-Stream':'chunks' }), json: body, timeout_ms: 20*60*1000 };
    const h = { onBegin: ()=>{}, onLine: (line)=>{ if (box){ box.textContent += '\n' + line; box.scrollTop = box.scrollHeight; } }, onEnd: ()=>{} };
    try { await nknSendRelayStream(req, h, req.timeout_ms); toast('Create finished'); refreshModels(true); }
    catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Create failed', false); }
  } else {
    try{
      const res = await fetch(S.base.replace(/\/+$/, '')+'/api/create', { method:'POST', headers: authHeaders({'Content-Type':'application/json'}), body: JSON.stringify(body) });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const reader=res.body.getReader(); const decoder=new TextDecoder('utf-8'); let leftover='';
      while(true){
        const { value, done } = await reader.read(); if (done) break;
        const s=decoder.decode(value, { stream:true }); const combined=leftover+s; const lines=combined.split(/\r?\n/); leftover = lines.pop() || '';
        for (const ln of lines){ if (!ln.trim()) continue; if (box){ box.textContent += '\n' + ln; box.scrollTop = box.scrollHeight; } }
      }
      if (leftover && box) box.textContent += '\n' + leftover;
      toast('Create finished'); refreshModels(true);
    }catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Create failed', false); }
  }
}
async function showModel(){
  const model = qs('showModel')?.value.trim(); if (!model){ toast('Enter model', false); return; }
  const verbose = qs('showVerbose')?.value === 'true';
  const box=qs('adminOut'); if (box){ box.style.display='block'; }
  try{ if (box) box.textContent = j(await callJSON('/api/show', { model, ...(verbose?{verbose:true}:{}) })); toast('Show ok'); }
  catch(e){ if (box) box.textContent='Error: '+e.message; toast('Show error', false); }
}
async function copyModel(){
  const src=qs('copySrc')?.value.trim(), dst=qs('copyDst')?.value.trim(); if (!src || !dst){ toast('Enter source & destination', false); return; }
  const box=qs('adminOut'); if (box){ box.style.display='block'; }
  try{ if (box) box.textContent = j(await callJSON('/api/copy', { source: src, destination: dst })); toast('Copy ok'); refreshModels(true); }
  catch(e){ if (box) box.textContent='Error: '+e.message; toast('Copy error', false); }
}
async function deleteModel(){
  const model = qs('deleteModel')?.value.trim(); if (!model){ toast('Enter model to delete', false); return; }
  const box=qs('adminOut'); if (box){ box.style.display='block'; }
  try{ if (box) box.textContent = j(await callJSON('/api/delete', { model }, undefined, 'DELETE')); toast('Delete ok'); refreshModels(true); }
  catch(e){ if (box) box.textContent='Error: '+e.message; toast('Delete error', false); }
}

/* ===================== PULL / PUSH / EMBEDDINGS / BLOBS ===================== */
async function pullModel(){
  const name = qs('pullModelName')?.value.trim(); if (!name){ toast('Enter a model', false); return; }
  const body={ model:name, stream:true };
  const box=qs('pullPushOut'); if (box){ box.style.display='block'; box.textContent='(pulling…)\n'; }

  if (S.transport==='nkn'){
    const req = { url: S.base.replace(/\/+$/, '')+'/api/pull', method:'POST', headers: authHeaders({ 'X-Relay-Stream':'chunks' }), json: body, timeout_ms: 60*60*1000 };
    const h = { onBegin: ()=>{}, onLine: (line)=>{ if (box){ box.textContent+='\n'+line; box.scrollTop=box.scrollHeight; } }, onEnd: ()=>{} };
    try { await nknSendRelayStream(req, h, req.timeout_ms); toast('Pull finished'); refreshModels(true); }
    catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Pull failed', false); }
  } else {
    try{
      const res = await fetch(S.base.replace(/\/+$/, '')+'/api/pull', { method:'POST', headers: authHeaders({'Content-Type':'application/json'}), body: JSON.stringify(body) });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const reader=res.body.getReader(); const decoder=new TextDecoder('utf-8'); let leftover='';
      while(true){
        const { value, done } = await reader.read(); if (done) break;
        const s=decoder.decode(value, { stream:true }); const combined=leftover+s; const lines=combined.split(/\r?\n/); leftover = lines.pop() || '';
        for (const ln of lines){ if (!ln.trim()) continue; if (box){ box.textContent+='\n'+ln; box.scrollTop=box.scrollHeight; } }
      }
      if (leftover && box) box.textContent+='\n'+leftover;
      toast('Pull finished'); refreshModels(true);
    }catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Pull failed', false); }
  }
}
async function pushModel(){
  const name = qs('pushModelName')?.value.trim(); if (!name){ toast('Enter namespace/model:tag', false); return; }
  const body={ model:name, stream:true };
  const box=qs('pullPushOut'); if (box){ box.style.display='block'; box.textContent='(pushing…)\n'; }

  if (S.transport==='nkn'){
    const req = { url: S.base.replace(/\/+$/, '')+'/api/push', method:'POST', headers: authHeaders({ 'X-Relay-Stream':'chunks' }), json: body, timeout_ms: 60*60*1000 };
    const h = { onBegin: ()=>{}, onLine: (line)=>{ if (box){ box.textContent+='\n'+line; box.scrollTop=box.scrollHeight; } }, onEnd: ()=>{} };
    try { await nknSendRelayStream(req, h, req.timeout_ms); toast('Push finished'); refreshModels(true); }
    catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Push failed', false); }
  } else {
    try{
      const res = await fetch(S.base.replace(/\/+$/, '')+'/api/push', { method:'POST', headers: authHeaders({'Content-Type':'application/json'}), body: JSON.stringify(body) });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const reader=res.body.getReader(); const decoder=new TextDecoder('utf-8'); let leftover='';
      while(true){
        const { value, done } = await reader.read(); if (done) break;
        const s=decoder.decode(value, { stream:true }); const combined=leftover+s; const lines=combined.split(/\r?\n/); leftover = lines.pop() || '';
        for (const ln of lines){ if (!ln.trim()) continue; if (box){ box.textContent+='\n'+ln; box.scrollTop=box.scrollHeight; } }
      }
      if (leftover && box) box.textContent+='\n'+leftover;
      toast('Push finished'); refreshModels(true);
    }catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Push failed', false); }
  }
}
async function doEmbeddings(){
  const model = qs('embModel')?.value.trim(); if (!model){ toast('Enter an embedding model', false); return; }
  const endpoint = qs('embEndpoint')?.value || 'embed';
  const input = parseMaybeJSON(qs('embInput')?.value) ?? '';
  const options = parseMaybeJSON(qs('embOptions')?.value);
  const keep_alive = qs('embKeepAlive')?.value.trim();
  const out=qs('embOut'); if (out){ out.style.display='block'; out.textContent='(requesting)…'; }
  try{
    if (endpoint==='embed'){
      const body={ model, input, ...(options?{options}:{}) , ...(keep_alive?{keep_alive}:{}) };
      const resp = await callJSON('/api/embed', body);
      if (out) out.textContent = j(resp);
    } else {
      const body={ model, prompt: (typeof input==='string' ? input : JSON.stringify(input)), ...(options?{options}:{}) , ...(keep_alive?{keep_alive}:{}) };
      const resp = await callJSON('/api/embeddings', body);
      if (out) out.textContent = j(resp);
    }
    toast('Embeddings complete');
  }catch(e){ if (out) out.textContent = 'Error: ' + e.message; toast('Embeddings failed', false); }
}
async function sha256Hex(file){
  const buf=await file.arrayBuffer(); const hash=await crypto.subtle.digest('SHA-256', buf);
  const arr=Array.from(new Uint8Array(hash)); return 'sha256:'+arr.map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function blobHead(){
  const d=qs('blobDigest')?.value.trim(); if (!d){ toast('Enter digest', false); return; }
  const box=qs('blobOut'); if (box){ box.style.display='block'; }
  try{ const r=await headBlob(d); if (box) box.textContent = `HEAD ${d} → ${r.status}\n`+j(r.headers); toast(r.status===200?'Blob exists':'Not found', r.status===200); }
  catch(e){ if (box) box.textContent = 'Error: ' + e.message; toast('HEAD error', false); }
}
async function blobPush(){
  const input=qs('blobFile'); const file=input?.files && input.files[0]; if (!file){ toast('Choose a file', false); return; }
  const box=qs('blobOut'); if (box){ box.style.display='block'; box.textContent='(hashing file…)\n'; }
  let digest=qs('blobDigest')?.value.trim();
  if (!digest){ digest=await sha256Hex(file); if (qs('blobDigest')) qs('blobDigest').value=digest; if (box) box.textContent += `Computed digest: ${digest}\n`; }
  try{
    if (S.transport==='nkn' && file.size > 4*1024*1024){ throw new Error('File too large for NKN upload; switch transport to HTTP'); }
    const r=await postBlob(digest, file);
    if (box) box.textContent += `POST ${digest} → ${r.status}\n`+j(r.headers);
    toast(r.status===201?'Uploaded':'Done');
  }catch(e){ if (box) box.textContent += '\nError: ' + e.message; toast('Upload error', false); }
}

/* ===================== EVENTS ===================== */
function reflectInputs(){
  if (qs('transport')) qs('transport').value=S.transport;
  if (qs('baseUrl'))   qs('baseUrl').value=S.base;
  if (qs('relayAddr')) qs('relayAddr').value=S.relayAddr;
  if (qs('apiKey'))    qs('apiKey').value=S.apiKey;
}
function saveSettings(){
  S.transport = qs('transport')?.value || S.transport;
  S.base = (qs('baseUrl')?.value.trim() || S.base);
  S.relayAddr = qs('relayAddr')?.value.trim() || '';
  S.apiKey = qs('apiKey')?.value.trim() || '';
  localStorage.setItem('ollama.transport', S.transport);
  localStorage.setItem('ollama.base', S.base);
  localStorage.setItem('ollama.relayAddr', S.relayAddr);
  localStorage.setItem('ollama.apiKey', S.apiKey);
  toast('Saved settings'); reflectTransportUI();

  // restart health loops / models poller
  if (S.transport==='nkn') nknEnsureClient();
  startHttpPingLoop();
  _startModelsPoller();
  refreshModels(true);
}
function bindEvents(){
  qs('transport')?.addEventListener('change', saveSettings);
  qs('nknConnectBtn')?.addEventListener('click', ()=>nknEnsureClient());
  qs('nknDisconnectBtn')?.addEventListener('click', ()=>{
    try{ S.nkn.client && S.nkn.client.close(); }catch{}
    S.nkn.client=null; S.nkn.ready=false;
    reflectTransportUI();
  });
  qs('saveBtn')?.addEventListener('click', saveSettings);

  // Inspect
  qs('listModels')?.addEventListener('click', listModels);
  qs('listPS')?.addEventListener('click', listPS);
  qs('getVersion')?.addEventListener('click', getVersion);

  // Generate
  qs('genGo')?.addEventListener('click', doGenerate);

  // Chat & sessions
  qs('chatModelSelect')?.addEventListener('change', (e)=>{ S.chat.currentModel=e.target.value; renderSessionListForModel(); saveChatStore(); });
  qs('chatSessionSelect')?.addEventListener('change', (e)=>{ ensureModelBucket(S.chat.currentModel).lastUsedSid=e.target.value; S.chat.sid=e.target.value; saveChatStore(); renderChatSession(); });
  qs('chatNewSession')?.addEventListener('click', ()=>{ const sid=newSession(S.chat.currentModel); renderSessionListForModel(); });
  qs('chatRenameSession')?.addEventListener('click', ()=>{ const name=prompt('Session name?', currentSession()?.name || '') || ''; if (name){ renameSession(S.chat.currentModel, S.chat.sid, name); renderSessionListForModel(); } });
  qs('chatDeleteSession')?.addEventListener('click', ()=>{ if (confirm('Delete this session?')){ deleteSession(S.chat.currentModel, S.chat.sid); renderSessionListForModel(); } });
  qs('chatSystem')?.addEventListener('change', setSystemFromUI);
  qs('chatSend')?.addEventListener('click', chatSend);
  qs('chatUserInput')?.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); chatSend(); } });

  // Upload/Download messages JSON
  qs('chatDownload')?.addEventListener('click', ()=>{ const sess=currentSession(); if (!sess) return; downloadJSON((sess.name||'session')+'.json', sess.messages); });
  qs('chatUpload')?.addEventListener('change', async (e)=>{
    const file=e.target.files && e.target.files[0]; if (!file) return;
    try{
      const txt=await file.text(); const arr=JSON.parse(txt);
      if (!Array.isArray(arr)) throw new Error('JSON must be an array of messages');
      const sess=currentSession(); if (!sess) return;
      sess.messages = arr; sess.updatedAt=now(); saveChatStore(); renderChatSession(); toast('Messages loaded');
    }catch(err){ toast('Upload failed: '+err.message, false); }
    e.target.value='';
  });

  // Admin
  qs('createFromModel')?.addEventListener('click', createFromModel);
  qs('showBtn')?.addEventListener('click', showModel);
  qs('copyBtn')?.addEventListener('click', copyModel);
  qs('deleteBtn')?.addEventListener('click', deleteModel);

  // Pull / Push
  qs('pullModel')?.addEventListener('click', pullModel);
  qs('pushModel')?.addEventListener('click', pushModel);

  // Embeddings
  qs('embGo')?.addEventListener('click', doEmbeddings);

  // Blobs
  qs('blobHead')?.addEventListener('click', blobHead);
  qs('blobPush')?.addEventListener('click', blobPush);

  // Network visibility & online/offline
  let visTimer=null;
  document.addEventListener('visibilitychange', ()=>{
    clearTimeout(visTimer);
    visTimer = setTimeout(()=>{
      if (!document.hidden){
        refreshModels(true);
        if (S.transport==='http') httpPingBase();
        if (S.transport==='nkn') nknEnsureClient();
      }
    }, VISIBILITY_DEBOUNCE_MS);
  });
  window.addEventListener('online', ()=>{
    toast('Network online'); refreshModels(true);
    if (S.transport==='nkn') nknEnsureClient();
    if (S.transport==='http') httpPingBase();
  });
  window.addEventListener('offline', ()=>{ toast('Network offline', false); });
}

/* ===================== INIT ===================== */
function init(){
  loadChatStore();
  reflectInputs(); reflectTransportUI(); bindEvents();

  // kick health loops
  startHttpPingLoop();
  _startModelsPoller();

  if (S.transport==='nkn') nknEnsureClient();

  if (qs('status')) qs('status').innerHTML = `<span class="dot ok"></span><span>Ready</span>`;

  // first-time model load + scheduled retry on failure handled inside
  refreshModels(true);
}
document.addEventListener('DOMContentLoaded', init);
</script>

</body>
</html>
